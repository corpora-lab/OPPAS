/*  Corresponding procedure in C syntax:

	void quicksort (int left,int right)
	{
		int lo,hi,piv;
		if (left >= right) return;
		piv = a[right]; lo = left; hi = right;
		while (lo <= hi) {
			if (a[hi] > piv) {
				hi--;
			} else {
				swap a[lo],a[hi];
				lo++;
			}
		}
		quicksort(left,hi);
		quicksort(lo,right);
	}	

	Ref: Schwoon, Stefan. Model-checking pushdown systems. Diss. Technische Universität München, 2002. 
	We consider an array of 2 elements.
*/

formulas = 	F (ret And main),
			XNu (ret And main),
			F ( G (okay)),
			XNu (okay),
			F (ret And main And (okay)),
			XNu (ret And main And (okay));


program:
bool  okay;
s3 left, right, lo, hi;
u4 piv, swapLeft, swapRight, tmp;
u4[4] a;


main() {
	left = 0s3;
	right = 3s3;
	a[0s3] = *;
	a[1s3] = *;
	a[2s3] = *;
	a[3s3] = *;
	qs();
}

qs() {
	if (left >= right) {
	} else {
		piv = a[right]; 
		lo = left;
		hi = right;
		while (lo <= hi) { 
			qsif();
		}

		// recursive calls
		if (lo == 0s3 && right == 1s3){
			qsRec0();
		} else {
			if (lo == 0s3 && right == 2s3){
				qsRec1();
			} else {
				if (lo == 0s3 && right == 3s3){
					qsRec2();
				} else {
					if (lo == 1s3 && right == 2s3){
						qsRec3();
					} else {
						if (lo == 1s3 && right == 3s3){
							qsRec4();
						} else {
							if (lo == 2s3 && right == 3s3){
								qsRec5();
							} else {
								qsRec6();
							}
						}
					}
				}
			} 
		}
	}
}

qsif() { 
	if (a[hi] > piv){
		hi = hi - 1s3; 
	} else {
		swapLeft = lo;
		swapRight = hi;
		swapElements();
		lo = lo + 1s3;
	}
}

swapElements() {
	tmp = a[swapLeft];
	a[swapLeft] = a[swapRight];
	a[swapRight] = tmp;
	okay = a[0s3] <= a[1s3] && a[1s3] <= a[2s3] && a[2s3] <= a[3s3];
}

//recursive cases depending on the value of lo and right for a four-elements array
qsRec0() {
	right = hi;
	qs();
	left = 0s3; 
	right = 1s3;
	qs();
}

qsRec1() {
	right = hi;
	qs();
	left = 0s3; 
	right = 2s3;
	qs();
}

qsRec2() {
	right = hi;
	qs();
	left = 0s3; 
	right = 3s3;
	qs();
}

qsRec3() {
	right = hi;
	qs();
	left = 1s3; 
	right = 2s3;
	qs();
}

qsRec4() {
	right = hi;
	qs();
	left = 1s3; 
	right = 3s3;
	qs();
}

qsRec5() {
	right = hi;
	qs();
	left = 2s3; 
	right = 3s3;
	qs();
}

qsRec6() {
	right = hi;
	qs();
	//abort second recursive call, it involves at most one element
	//qs();
}