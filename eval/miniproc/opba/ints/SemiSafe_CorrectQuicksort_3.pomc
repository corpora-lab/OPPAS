/*  TODO: add a Java sketch of this model.
	Ref: Schwoon, Stefan. Model-checking pushdown systems. Diss. Technische Universität München, 2002. 
*/

formulas = 	F (ret And main),
			XNu (ret And main), 
			F ( G (okay)),
			XNu (okay), 
			G ((call And main) --> ~ (PNu exc Or XNu exc)), 
			G ((call And qs) --> ~ (PNu exc Or XNu exc)), 
			((PNu exc) Or (XNu exc)) --> ((PNu (exc And hasParsed)) Or (XNu (exc And hasParsed))), 
			((PNu exc) Or (XNu exc)) --> ((PNu (exc And okay)) Or (XNu (exc And okay))), 
			G ( (call And accessValues) --> (hasParsed) Or (T Sd han )), 
			(F (ret And main)) Or (XNu (exc And hasParsed)), 
			(XNu (ret And main)) Or (XNu (exc And hasParsed)), 
			(F ( G (okay))) Or (XNu (exc And hasParsed)), 
			(XNu (okay)) Or (XNu (exc And hasParsed)), 
			(F (ret And main And (okay))) Or (XNu (exc And hasParsed));
			

program:
bool  okay, hasParsed;
s8 tmp, left, right, lo, eq, hi, piv, swapLeft, swapRight;
s8[3] a;


main() {
	left = 0s8;
	right = 2s8;
	hasParsed = false;
	try {
	 	qs();
	} catch {
		hasParsed = true;
		qs();
	}
}

qs() {
	if (left >= right) {
	} else {
		piv = a[right]; 
		eq = left;
		lo = eq;
		hi = right;
		while (lo <= hi) { 
			qsif();
		}

		// recursive calls
		if (lo == 0s8 && right == 1s8){
			qsRec0();
		} else {
			if (lo == 0s8 && right == 2s8){
				qsRec1();
			} else {
				if (lo == 1s8 && right == 2s8){
					qsRec2();
				} else {
					qsRec3();
				}
			} 
		}
	}
}

qsif() { 
	if (a[hi] > piv){
		hi = hi - 1s8; 
	} else {
		swapLeft = lo;
		swapRight = hi;
		swapElements();
		if (a[lo] < piv){
			swapLeft = lo;
			swapRight = eq;
			swapElements();
		} else {}
		lo = lo + 1s8;
	}
}

swapElements() {
	accessValues();
	tmp = a[swapLeft];
	a[swapLeft] = a[swapRight];
	a[swapLeft] = tmp;
	okay = a[0s8] <= a[1s8];
}

accessValues(){
	if (*){
		throw;
	} else {}
}

//recursive cases depending on the value of lo and right for a three-elements array
qsRec0() {
	left = 0s8;
	right = eq - 1s8;
	qs();
	left = 0s8; 
	right = 1s8;
	qs();
}

qsRec1() {
	left = 0s8;
	right = eq - 1s8;
	qs();
	left = 0s8; 
	right = 2s8;
	qs();
}

qsRec2() {
	left = 0s8;
	right = eq - 1s8;
	qs();
	left = 1s8; 
	right = 2s8;
	qs();
}

qsRec3() {
	left = 0s8;
	right = eq - 1s8;
	qs();
	//abort second recursive call, it involves at most one element
	//qs();
}